<html>
<head>
	<title>API Plugin</title>
	<link rel="stylesheet" href="../../../assets/stylesheets/documentation.css" />
</head>
<body class="tesla-documentation">

<h2>About the API Class</h2>

<p>This class is used to interpret or connect with UniFaction APIs. It treats APIs like they're a standard function. It
automatically encrypts and decrypts the APIs so that no additional work is necessary.</p>


<h2>How to call an API</h2>

<p>Connecting to an API is simple. You only need to run one line:
<pre>
	$response = Connect::call("http://example.com/api/public-api", $apiPacket);
</pre>
<p>The URL is the API that you're calling, and the $apiPacket value is data you want the API to receive. You can only send
one variable to the API, but it can be an array of data.</p>

<p>The API will respond with a value, often with "1" to indicate true or null if false. $response captures the value.</p>


<h2>How to call Private APIs</h2>
	
<p>Private APIs require you to have an API key to use them, but the command is otherwise identical to a public API call.
If you have an API key, you can connect to the API like this:</p>
<pre>
	$response = Connect::call("http://example.com/api/private-api", $apiPacket, $key);
</pre>

<h2>How to call Encrypted APIs</h2>

<p>Encrypted APIs are just like private APIs, except that their response is encrypted and will need to be decrypted. This
is for APIs that return data that needs to remain private.</p>

<p>If the data returned is encrypted, just set the final parameter to true:</p>

	$response = Connect::call("http://example.com/api/encrypted-api", $apiPacket, $key, true);

<p>If you receive gibberish from an API, it's probably because you forgot to set the last value to true. Setting it should
decrypt the value properly.</p>

<p>Notice the "true" at the end of the function.</p>


<h2>Shared-Environment API Calls</h2>

<p>If you want to use local API calls (or development API calls) to other local sites without disrupting your production
code, you can optionally use the Network class to switch between the site URLs and site keys for your APIs. Example:</p>
<pre>
	$siteData = Network::get("mySite");		// Returns array("url" => "http://mysite.local", "key" => "abcdefg...");
	
	$response = Connect::call($siteData['site_url'] . "/api/shared-api", $apiPacket, $siteData['site_key']);
</pre>
<p>With this method your localhost environment will save the URL and Keys differently than your production environment,
preventing you from having to modify your code. Refer to the Network class to understand this behaviour completely.</p>
	
	
<h2>How to pass a file to an API</h2>

<p>Passing a file to an API is simple. Just include the path to the file as a string into the paramater as shown:</p>
<pre>
	$pathToImage = $_FILES['image']['tmp_name'];
	$response = Connect::call("http://example.com/api/public-file-upload", $apiPacket, "", false, $pathToImage);
</pre>
	
<h2>How to create your own API</h2>

<p>To create your own public API, you just need to return data. For example, this page would be a valid API:</p>
<pre>
	echo "Hello World";
</pre>
<p>However, most APIs will make use of some data that is sent to them. You can retrieve this data with the following line:</p>
<pre>
	$apiData = API::interpret($_GET['api']);
</pre>
<p>This will turn $apiData into the same variable that was sent with the API call. A final API page might look like this:</p>
<textarea>
// Make sure the user sent a packet
if(!isset($_GET['api'])) { die("You didn't provide any data."); }

// Get the packet data
$apiData = API::interpret($_GET['api']);

// Tell the user what type of value they sent
if(is_array($apiData))
{
	API::respond("You sent an array!");
}

API::respond("You didn't send an array. Oh well.");
</textarea>

<h2>How to create private APIs</h2>

<p>Private APIs are basically identical, except that you need to have the API key of the caller saved into the
network_data table. The reference variable of their site and API key the user passed must match.</p>

<p>To prove that the user has a valid key (and that it exists in your database), you can run this line:</p>
<pre>
	if(!$key = Network::key($_GET['site'])) { die("That site does not have an API Key registered here."); }
</pre>
<p>The only other change to private APIs are that we're dealing with a few additional variables:</p>
<pre>
	1. $_GET['site'] is the reference variable of the site that's using the API (e.g. "joes_blog")
	2. $_GET['salt'] is the salt that you're using for this particular API call
	3. $_GET['conf'] is a confirmation value that prevents URL tampering
</pre>
<p>Fortunately, all of the work of interpreting these values has been taken care of for you. You just need to include them
in the receive call, like this:</p>
<pre>
	$apiData = API::interpret($_GET['api'], $key, $_GET['salt'], $_GET['conf']);
</pre>
	
<h2>A Quick API Example</h2>
<textarea>
// This API responds with "pong" when you send it "ping". Otherwise it says "What?"
// You can call this API with:
//			Connect::call("http://example.com/api/ping-pong", "ping", $key);

// If the proper information wasn't sent, exit the page
if(!isset($_GET['enc']) or !$key = Network::key($_GET['site'])) { exit; }

// Interpret the data sent
$apiData = API::interpret($_GET['api'], $key, $_GET['salt'], $_GET['conf']);

if($apiData == "ping") { echo "pong"; } else { echo "What?" }
</textarea>
	
<h2>Methods Available</h2>
<pre>
$response	= Connect::call($apiURL, $apiData, $apiKey, $sendFile = "");

$apiData	= API::interpret($apiData, $apiKey, $apiSalt, $apiConf);

// Returns the API's response (and ends the script)
API::respond($apiResponse);
</pre>
</body>
</html>